#version 430

layout(local_size_x = 256) in;

struct Particle {
    vec4 pos;
    vec4 vel;
};

layout(std430, binding = 0) buffer CurrentState { Particle particlesIn[]; };
layout(std430, binding = 1) buffer NextState { Particle particlesOut[]; };

uniform float dt;
uniform int numParticles;
uniform float softening;
uniform vec4 mouse;

shared vec4 sharedPos[256];

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= numParticles) return;

    vec4 myPos = particlesIn[index].pos;
    vec4 myVel = particlesIn[index].vel;
    vec3 acc = vec3(0.0);

    if (mouse.w > 0.0) {
        vec3 d = mouse.xyz - myPos.xyz;
        float distSqr = dot(d, d) + 100.0;
        float force = mouse.z / (distSqr * sqrt(distSqr));
        acc += d * force * 1000.0;
    }

    for (int tile = 0; tile < numParticles; tile += 256) {
        uint tileIndex = tile + gl_LocalInvocationID.x;
        if (tileIndex < numParticles) {
            sharedPos[gl_LocalInvocationID.x] = particlesIn[tileIndex].pos;
        } else {
            sharedPos[gl_LocalInvocationID.x] = vec4(0.0);
        }
        
        barrier();
        memoryBarrierShared();

        for (int i = 0; i < 256; i++) {
            vec4 otherPos = sharedPos[i];
            vec3 r = otherPos.xyz - myPos.xyz;
            float distSqr = dot(r, r) + softening * softening;
            float dist = sqrt(distSqr);
            float f = (otherPos.w) / (distSqr * dist);
            acc += r * f;
        }
        
        barrier();
    }

    myVel.xyz += acc * dt;
    myPos.xyz += myVel.xyz * dt;

    if (abs(myPos.x) > 2000.0) myVel.x *= -0.5;
    if (abs(myPos.y) > 2000.0) myVel.y *= -0.5;
    if (abs(myPos.z) > 2000.0) myVel.z *= -0.5;

    particlesOut[index].pos = myPos;
    particlesOut[index].vel = myVel;
}
